---
title: "RNAseq ASCA Analysis"
author: "Ariana S Huffmyer"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

Note that this script must be run on an HPC or server with at least 100 GB of memory to run. 

Trigg et al 2020 BMC Genomics 
- Found location of "diminishing returns" of PC loading scores to determine which proteins were "most important" to each PC 
https://doi.org/10.1186/s12864-020-07127-3

Analysis of RNAseq data using ASCA (ANOVA Simultaneous Component Analysis) to examine how gene expression changes across temperatures for each parental phenotype.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# The following setting is important, do not omit.
options(stringsAsFactors = FALSE) #Set Strings to character
```

# Load libraries

```{r}
library("tidyverse")
library("genefilter")
library("DESeq2")
library("RColorBrewer")
library("ALASCA")
library(purrr)
library(readr)
library(tibble)
library(ComplexHeatmap)
library(circlize)
```

# Data input and filtering

Import the data files.

```{r}
#load metadata sheet with sample name and developmental stage information
metadata <- read.csv("data/rna_seq/sample_rnaseq_metadata.csv", header = TRUE, sep = ",")%>%
  dplyr::select(sample, temperature, parent, symbiont, phenotype)
metadata$code<-paste0(metadata$temperature, "_", metadata$parent)
head(metadata)

#load gene count matrix generated from cluster computation
gcount <- as.data.frame(read.csv("data/rna_seq/Mcapitata2023_gene_count_matrix_STAR.csv", row.names="gene_id"), colClasses = double)
head(gcount)
```

Check that there are no genes with 0 counts across all samples.

```{r}
dim(gcount) 

gcount<-gcount %>%
     mutate(Total = rowSums(.[, 1:54]))%>%
    filter(!Total==0)%>%
    dplyr::select(!Total)

dim(gcount)
```

Conduct data filtering using pOverA approach.

```{r}
filt <- filterfun(pOverA(0.1,10))

#create filter for the counts data
gfilt <- genefilter(gcount, filt)

#identify genes to keep by count filter
gkeep <- gcount[gfilt,]

#identify gene lists
gn.keep <- rownames(gkeep)

#gene count data filtered in PoverA, P percent of the samples have counts over A
gcount_filt <- as.data.frame(gcount[which(rownames(gcount) %in% gn.keep),])

#How many rows do we have before and after filtering?
nrow(gcount) #Before
nrow(gcount_filt) #After
```

Prepare sample names.

```{r}
# Function to extract 'R' followed by numbers from column names
extract_R_numbers <- function(col_names) {
  sub("R(\\d+).*", "\\1", col_names)
}

# Apply the function to all column names
new_col_names <- sapply(names(gcount_filt), extract_R_numbers)

# Rename the columns
names(gcount_filt) <- paste0("R", new_col_names)

# remove "trim." from the name
names(gcount_filt) <- gsub("trim\\.", "", names(gcount_filt))

# Output the modified dataframe
names(gcount_filt)
length(names(gcount_filt))
```

# Format metadata and count data

Convert temperature and metadata categories to factors.

```{r}
metadata$temperature<-as.factor(metadata$temperature)
metadata$parent<-as.factor(metadata$parent)
metadata$symbiont<-as.factor(metadata$symbiont)
metadata$code<-as.factor(metadata$code)
```

Set levels of factors.

```{r}
metadata$temperature<-factor(metadata$temperature, levels=c("27", "30", "33"))
metadata$parent<-factor(metadata$parent, levels=c("Wildtype", "Bleached", "Nonbleached"))
metadata$code<-factor(metadata$code, levels=c("27_Wildtype", "27_Bleached", "27_Nonbleached", "30_Wildtype", "30_Bleached", "30_Nonbleached", "33_Wildtype", "33_Bleached", "33_Nonbleached"))
```

Reorder metadata to match gene count columns.

```{r}
list<-colnames(gcount_filt)
list<-as.factor(list)

metadata$sample<-as.factor(metadata$sample)

# Re-order the levels
metadata$sample <- factor(as.character(metadata$sample), levels=list)
# Re-order the data.frame
metadata_ordered <- metadata[order(metadata$sample),]
metadata_ordered$sample

head(metadata_ordered)

metadata_ordered$sample
colnames(gcount_filt)
head(gcount_filt)
```

# Normalize data using VST transformation

Create a DESeqDataSet and apply variance stabilizing transformation for normalization.

```{r}
#Set DESeq2 design
gdds <- DESeqDataSetFromMatrix(countData = gcount_filt,
                              colData = metadata_ordered,
                             design = ~temperature + parent + temperature:parent)
```

Calculate size factors and check if VST can be used (size factors should be <4).

```{r}
SF.gdds <- estimateSizeFactors(gdds)
print(sizeFactors(SF.gdds))

all(sizeFactors(SF.gdds)) < 4
```

Apply VST transformation.

```{r}
gvst <- vst(gdds, blind=TRUE)
head(assay(gvst), 3)
dim(gvst)
```

Extract normalized counts.

```{r}
normalized_counts <- assay(gvst)
dim(normalized_counts)
head(normalized_counts)
```

# Prepare data for ASCA analysis

Create long format data with sample, temperature, parent, gene, and value columns.

```{r}
# Transpose and convert to dataframe
normalized_df <- as.data.frame(t(normalized_counts))
normalized_df$sample <- rownames(normalized_df)
rownames(normalized_df) <- NULL

# Add metadata
normalized_df <- normalized_df %>%
  left_join(metadata_ordered %>% dplyr::select(sample, temperature, parent), by = "sample")

# Reorder columns to put metadata first
normalized_df <- normalized_df %>%
  dplyr::select(sample, temperature, parent, everything())

head(normalized_df[, 1:10])
```

Make sure there are no missing values or NAs. 
```{r}
str(normalized_df)

sum(is.na(normalized_df))
sum(is.infinite(as.matrix(normalized_df[, -(1:3)])))

na_per_col <- colSums(is.na(normalized_df))
summary(na_per_col)

cols_with_na <- names(na_per_col[na_per_col > 0])
length(cols_with_na)
cols_with_na[1:10]

inf_per_col <- colSums(is.infinite(as.matrix(normalized_df[, -(1:3)])))
names(inf_per_col[inf_per_col > 0])

na_per_row <- rowSums(is.na(normalized_df))
summary(na_per_row)

expr_mat <- normalized_df[, -(1:3)]  # expression only

zero_var_cols <- apply(expr_mat, 2, function(x) sd(x, na.rm = TRUE) == 0)
sum(zero_var_cols)
names(zero_var_cols[zero_var_cols])[1:10]

nzv_cols <- apply(expr_mat, 2, function(x) sd(x, na.rm = TRUE) < 1e-6)
sum(nzv_cols)

with(normalized_df, table(temperature, parent))
```

Convert to long format for ALASCA.

```{r}
str(normalized_df)

long_data <- normalized_df %>%
  pivot_longer(cols = -c(sample, temperature, parent), 
               names_to = "variable", 
               values_to = "value")

str(long_data)
head(long_data)
```

View any NA or Inf values. 

```{r}
long_data%>%
  filter(if_any(everything(), is.na))

long_data%>%
  filter(is.infinite(value))
```

No NA or INF values. 

# Run ASCA analysis for all parental phenotypes

For initial analysis run with 10 runs, do full validation at 1000 runs. 

Run ASCA model with temperature and phenotype as the main effect and sample as random effect.

Samples are stratified by group. With an n=6, random resampling can sometimes cause validation to fail if resampling excludes a group randomly. This conducts random resampling with representatives of each group in each run. We will not perform additional scaling because data is already variance stabilize transformed. 

Analyze effects in the model of parent, temperature, and parent:temperature. Determine PC's for each effect. 

Full validation with 1000 runs takes about 1.5 h to run. Suggest to run this script as a background job. Needs to run with larger memory (100 GB). Alternatively, replace with n=10-15 validation runs. Only run 1000 validation runs for final analysis.   
```{r}
long_data<-long_data%>%
  mutate(code = interaction(temperature, parent, drop = TRUE))

set.seed(123)

res_all <- ALASCA(
  long_data,
  value ~ temperature * parent + (1|sample),
  effects=c("temperature", "parent", "temperature:parent"),
  n_validation_runs = 1000,
  scale_function = "none",
  validate = TRUE,
  stratification_column = "code",
  p_adjust_method = "fdr",
  reduce_dimensions = TRUE
)

saveRDS(res_all, file = "output/rna_seq/asca/asca_results_genes.rds")
```

Read in R data file of full validation run if not running full validation.
```{r}
res_all <- readRDS("output/rna_seq/asca/asca_results_genes.rds")
```

```{r}
#temp
plot(res_all, component = seq(1,10), effect = 1, type = 'scree')
#2 PCs >10%

#parent
plot(res_all, component = seq(1,10), effect = 2, type = 'scree')
#2 PCs >10%

#parent:temperature
plot(res_all, component = seq(1,10), effect = 3, type = 'scree')
#3 PCs >10%

#temp

#increase with temp
plot(res_all, effect = 1, component = 1, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("black"),
     my_theme = theme_classic())

#different at 30C than 27 and 33 
plot(res_all, effect = 1, component = 2, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("black"),
     my_theme = theme_classic())

#parent

#Different in bleached
plot(res_all, effect = 2, component = 1, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("black"),
     my_theme = theme_classic())

#Different between all parents
plot(res_all, effect = 2, component = 2, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("black"),
     my_theme = theme_classic())

#parent:temperature

#Different between parents at high temperature, linear response to temperature 
plot(res_all, effect = 3, component = 1, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("darkgray", "orange", "darkred"),
     my_theme = theme_classic())

#Different between parents at high temperature, with peak/decrease at 30C 
plot(res_all, effect = 3, component = 2, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("darkgray", "orange", "darkred"),
     my_theme = theme_classic())

#Higher in bleached across temperatures than NB/WT  
plot(res_all, effect = 3, component = 3, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("darkgray", "orange", "darkred"),
     my_theme = theme_classic())
```


```{r}
#temp
pdf(file="figures/rna_seq/asca/temp_scree_plot.pdf", width=6, height=4)
plot(res_all, component = seq(1,10), effect = 1, type = 'scree')
dev.off()
# 2 PCs

#parent
pdf(file="figures/rna_seq/asca/parent_scree_plot.pdf", width=6, height=4)
plot(res_all, component = seq(1,10), effect = 2, type = 'scree')
dev.off()
#2 PCs

#temp:parent
pdf(file="figures/rna_seq/asca/interaction_scree_plot.pdf", width=6, height=4)
plot(res_all, component = seq(1,10), effect = 3, type = 'scree')
dev.off()
#3 PCs
```

Temperature PCs
```{r}
pdf(file="figures/rna_seq/asca/temp_PC1.pdf", width=10, height=6)
plot(res_all, effect = 1, component = 1, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("black"),
     my_theme = theme_classic()+ theme(legend.position = "none"))
dev.off()
#Increase/decrease linearly with temp

pdf(file="figures/rna_seq/asca/temp_PC2.pdf", width=10, height=6)
plot(res_all, effect = 1, component = 2, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("black"),
     my_theme = theme_classic())
dev.off()
#higher/lower at 30°C
```

Parent PCs
```{r}
pdf(file="figures/rna_seq/asca/parent_PC1.pdf", width=10, height=6)
plot(res_all, effect = 2, component = 1, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("black"),
     my_theme = theme_classic())
dev.off()
#higher/lower in bleached than WT and NB

pdf(file="figures/rna_seq/asca/parent_PC2.pdf", width=10, height=6)
plot(res_all, effect = 2, component = 2, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("black"),
     my_theme = theme_classic())
dev.off()
#different in all parents, higher/lower in wildtype
```

Parent:Temperature PCs
```{r}
pdf(file="figures/rna_seq/asca/interaction_PC1.pdf", width=10, height=6)
plot(res_all, effect = 3, component = 1, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("darkgray", "darkred", "orange"),
     my_theme = theme_classic())
dev.off()
#Responsive to temp in B and NB but not WT, different at 33°C

pdf(file="figures/rna_seq/asca/interaction_PC2.pdf", width=10, height=6)
plot(res_all, effect = 3, component = 2, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("darkgray", "darkred", "orange"),
     my_theme = theme_classic())
dev.off()
#Responsive to temp in B and NB but not WT, different at 30-33*

pdf(file="figures/rna_seq/asca/interaction_PC3.pdf", width=10, height=6)
plot(res_all, effect = 3, component = 3, type = 'effect', 
     n_limit=20, 
     ribbon = TRUE,
     x_angle = 0, x_h_just= 0.5,
     flip_axis=TRUE,
     palette = c("darkgray", "darkred", "orange"),
     my_theme = theme_classic())
dev.off()
#Different in NB at elevated temp
```

# Determine top contributing genes to PCs quantitatively 

Identify top genes for each PC using a cumulative variance explained method for each PC. 

I am going to use an % threshold cut off (genes explaining the first X% of variance on each PC).

## Temperature: PC1 

```{r}
# 1. Extract all loadings for PC1 (effect 1 = temp)
temp_pc1_raw <- get_loadings(res_all, effect = 1, component = 1)

# ALASCA usually returns a list; first element holds the data
if (is.list(temp_pc1_raw) && !inherits(temp_pc1_raw, "data.frame")) {
  temp_pc1_df <- as.data.frame(temp_pc1_raw[[1]])
} else {
  temp_pc1_df <- as.data.frame(temp_pc1_raw)
}

# Identify gene column and numeric loading column
# (You can change "covars" if your object uses a different name)
if (!"covars" %in% names(temp_pc1_df)) {
  stop("Could not find 'covars' column in PC1 loadings; check the structure of pc1_df.")
}

gene_vec <- temp_pc1_df$covars

num_cols <- names(temp_pc1_df)[sapply(temp_pc1_df, is.numeric)]

if (length(num_cols) == 0) {
  stop("No numeric loading column found in PC1 loadings.")
}
loading_col <- num_cols[2]  # typically the PC1 loading column

temp_pc1_load <- temp_pc1_df %>%
  transmute(
    gene    = gene_vec,
    loading = .data[[loading_col]]
  ) %>%
  mutate(
    abs_loading = abs(loading)
  ) %>%
  arrange(desc(abs_loading)) %>%
  mutate(
    rank           = row_number(),
    cum_abs        = cumsum(abs_loading),
    cum_abs_prop   = cum_abs / sum(abs_loading),
    var_contrib    = loading^2,
    cum_var        = cumsum(var_contrib) / sum(var_contrib)
  )

# 2. Find "elbow" on normalized abs(loadings) curve (Kneedle-style)
n <- nrow(temp_pc1_load)
x <- (temp_pc1_load$rank - 1) / (n - 1 + 1e-9)  # normalized rank
y <- (temp_pc1_load$abs_loading - min(temp_pc1_load$abs_loading)) /
     (max(temp_pc1_load$abs_loading) - min(temp_pc1_load$abs_loading) + 1e-9)

#elbow is selected at the rank of the maximum deviation between the loading curve and diagonal reference
diff_xy <- x - y
elbow_idx  <- which.max(diff_xy)
elbow_rank <- temp_pc1_load$rank[elbow_idx]
elbow_gene <- temp_pc1_load$gene[elbow_idx]

# 3. 25% cumulative variance threshold as a comparison
idx_25_var <- which(temp_pc1_load$cum_var >= 0.25)[1]

temp_pc1_load <- temp_pc1_load %>%
  mutate(
    selected_elbow  = rank <= elbow_rank,
    selected_25_var = rank <= idx_25_var
  )

cat("PC1 important genes by elbow selection: ",
    sum(temp_pc1_load$selected_elbow), "\n")
cat("PC1 important genes by 25% variance selection: ",
    sum(temp_pc1_load$selected_25_var), "\n")

# 5. Diagnostic plots ------------------------------------------

# (a) Absolute loadings vs rank, with elbow + 80% var lines
pdf("figures/rna_seq/asca/temp_PC1_abs_loadings_rank.pdf", width = 7, height = 5)
ggplot(temp_pc1_load, aes(x = rank, y = abs_loading)) +
  geom_line() +
  geom_point(size = 0.7) +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
  annotate("text",
           x = idx_25_var,
           y = max(temp_pc1_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank (sorted by |loading|)",
    y = "|PC1 loading|",
    title = "Temperature PC1 absolute loadings and selection thresholds"
  ) +
  theme_classic()
dev.off()

# Cumulative proportion of variance (squared loadings)
pdf("figures/rna_seq/asca/temp_PC1_cumulative_variance.pdf", width = 7, height = 5)
ggplot(temp_pc1_load, aes(x = rank, y = cum_var)) +
  geom_line() +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
   annotate("text",
           x = idx_25_var,
           y = max(temp_pc1_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank",
    y = "Cumulative proportion of variance (loading^2)",
    title = "Temperature PC1 cumulative variance contribution"
  ) +
  theme_classic()
dev.off()

#export a list of genes contributing 80% of variance to PC1
temp_pc1_important_25 <- temp_pc1_load %>%
  filter(rank <= idx_25_var)

write.csv(temp_pc1_important_25,
          "output/rna_seq/asca/temp_PC1_important_genes.csv",
          row.names = FALSE)

```

## Temperature: PC2 

```{r}
# 1. Extract all loadings for PC2 (effect 1 = temp)
temp_pc2_raw <- get_loadings(res_all, effect = 1, component = 2)

# ALASCA usually returns a list; first element holds the data
if (is.list(temp_pc2_raw) && !inherits(temp_pc2_raw, "data.frame")) {
  temp_pc2_df <- as.data.frame(temp_pc2_raw[[1]])
} else {
  temp_pc2_df <- as.data.frame(temp_pc2_raw)
}

# Identify gene column and numeric loading column
# (You can change "covars" if your object uses a different name)
if (!"covars" %in% names(temp_pc2_df)) {
  stop("Could not find 'covars' column in PC2 loadings; check the structure of pc2_df.")
}

gene_vec <- temp_pc2_df$covars

num_cols <- names(temp_pc2_df)[sapply(temp_pc2_df, is.numeric)]

if (length(num_cols) == 0) {
  stop("No numeric loading column found in PC2 loadings.")
}
loading_col <- num_cols[2]  # typically the PC2 loading column

temp_pc2_load <- temp_pc2_df %>%
  transmute(
    gene    = gene_vec,
    loading = .data[[loading_col]]
  ) %>%
  mutate(
    abs_loading = abs(loading)
  ) %>%
  arrange(desc(abs_loading)) %>%
  mutate(
    rank           = row_number(),
    cum_abs        = cumsum(abs_loading),
    cum_abs_prop   = cum_abs / sum(abs_loading),
    var_contrib    = loading^2,
    cum_var        = cumsum(var_contrib) / sum(var_contrib)
  )

# 2. Find "elbow" on normalized abs(loadings) curve (Kneedle-style)
n <- nrow(temp_pc2_load)
x <- (temp_pc2_load$rank - 1) / (n - 1 + 1e-9)  # normalized rank
y <- (temp_pc2_load$abs_loading - min(temp_pc2_load$abs_loading)) /
     (max(temp_pc2_load$abs_loading) - min(temp_pc2_load$abs_loading) + 1e-9)

#elbow is selected at the rank of the maximum deviation between the loading curve and diagonal reference
diff_xy <- x - y
elbow_idx  <- which.max(diff_xy)
elbow_rank <- temp_pc2_load$rank[elbow_idx]
elbow_gene <- temp_pc2_load$gene[elbow_idx]

# 3. 25% cumulative variance threshold as a comparison
idx_25_var <- which(temp_pc2_load$cum_var >= 0.25)[1]

temp_pc2_load <- temp_pc2_load %>%
  mutate(
    selected_elbow  = rank <= elbow_rank,
    selected_25_var = rank <= idx_25_var
  )

cat("PC2 important genes by elbow selection: ",
    sum(temp_pc2_load$selected_elbow), "\n")
cat("PC2 important genes by 25% variance selection: ",
    sum(temp_pc2_load$selected_25_var), "\n")

# 5. Diagnostic plots ------------------------------------------

# (a) Absolute loadings vs rank, with elbow + 25% var lines
pdf("figures/rna_seq/asca/temp_PC2_abs_loadings_rank.pdf", width = 7, height = 5)
ggplot(temp_pc2_load, aes(x = rank, y = abs_loading)) +
  geom_line() +
  geom_point(size = 0.7) +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
  annotate("text",
           x = idx_25_var,
           y = max(temp_pc2_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank (sorted by |loading|)",
    y = "|PC2 loading|",
    title = "Temperature PC2 absolute loadings and selection thresholds"
  ) +
  theme_classic()
dev.off()

# Cumulative proportion of variance (squared loadings)
pdf("figures/rna_seq/asca/temp_PC2_cumulative_variance.pdf", width = 7, height = 5)
ggplot(temp_pc2_load, aes(x = rank, y = cum_var)) +
  geom_line() +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
   annotate("text",
           x = idx_25_var,
           y = max(temp_pc2_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank",
    y = "Cumulative proportion of variance (loading^2)",
    title = "Temperature PC2 cumulative variance contribution"
  ) +
  theme_classic()
dev.off()

#export a list of genes contributing 80% of variance to PC1
temp_pc2_important_25 <- temp_pc2_load %>%
  filter(rank <= idx_25_var)

write.csv(temp_pc2_important_25,
          "output/rna_seq/asca/temp_PC2_important_genes.csv",
          row.names = FALSE)

```


## Parent: PC1 

```{r}
# 1. Extract all loadings for PC1 (effect 2 = parent)
parent_pc1_raw <- get_loadings(res_all, effect = 2, component = 1)

# ALASCA usually returns a list; first element holds the data
if (is.list(parent_pc1_raw) && !inherits(parent_pc1_raw, "data.frame")) {
  parent_pc1_df <- as.data.frame(parent_pc1_raw[[1]])
} else {
  parent_pc1_df <- as.data.frame(parent_pc1_raw)
}

# Identify gene column and numeric loading column
# (You can change "covars" if your object uses a different name)
if (!"covars" %in% names(parent_pc1_df)) {
  stop("Could not find 'covars' column in PC1 loadings; check the structure of pc1_df.")
}

gene_vec <- parent_pc1_df$covars

num_cols <- names(parent_pc1_df)[sapply(parent_pc1_df, is.numeric)]

if (length(num_cols) == 0) {
  stop("No numeric loading column found in PC1 loadings.")
}
loading_col <- num_cols[2]  # typically the PC1 loading column

parent_pc1_load <- parent_pc1_df %>%
  transmute(
    gene    = gene_vec,
    loading = .data[[loading_col]]
  ) %>%
  mutate(
    abs_loading = abs(loading)
  ) %>%
  arrange(desc(abs_loading)) %>%
  mutate(
    rank           = row_number(),
    cum_abs        = cumsum(abs_loading),
    cum_abs_prop   = cum_abs / sum(abs_loading),
    var_contrib    = loading^2,
    cum_var        = cumsum(var_contrib) / sum(var_contrib)
  )

# 2. Find "elbow" on normalized abs(loadings) curve (Kneedle-style)
n <- nrow(parent_pc1_load)
x <- (parent_pc1_load$rank - 1) / (n - 1 + 1e-9)  # normalized rank
y <- (parent_pc1_load$abs_loading - min(parent_pc1_load$abs_loading)) /
     (max(parent_pc1_load$abs_loading) - min(parent_pc1_load$abs_loading) + 1e-9)

#elbow is selected at the rank of the maximum deviation between the loading curve and diagonal reference
diff_xy <- x - y
elbow_idx  <- which.max(diff_xy)
elbow_rank <- parent_pc1_load$rank[elbow_idx]
elbow_gene <- parent_pc1_load$gene[elbow_idx]

# 3. 25% cumulative variance threshold as a comparison
idx_25_var <- which(parent_pc1_load$cum_var >= 0.25)[1]

parent_pc1_load <- parent_pc1_load %>%
  mutate(
    selected_elbow  = rank <= elbow_rank,
    selected_25_var = rank <= idx_25_var
  )

cat("PC1 important genes by elbow selection: ",
    sum(parent_pc1_load$selected_elbow), "\n")
cat("PC1 important genes by 25% variance selection: ",
    sum(parent_pc1_load$selected_25_var), "\n")

# 5. Diagnostic plots ------------------------------------------

# (a) Absolute loadings vs rank, with elbow + 80% var lines
pdf("figures/rna_seq/asca/parent_PC1_abs_loadings_rank.pdf", width = 7, height = 5)
ggplot(parent_pc1_load, aes(x = rank, y = abs_loading)) +
  geom_line() +
  geom_point(size = 0.7) +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
  annotate("text",
           x = idx_25_var,
           y = max(parent_pc1_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank (sorted by |loading|)",
    y = "|PC1 loading|",
    title = "Parent PC1 absolute loadings and selection thresholds"
  ) +
  theme_classic()
dev.off()

# Cumulative proportion of variance (squared loadings)
pdf("figures/rna_seq/asca/parent_PC1_cumulative_variance.pdf", width = 7, height = 5)
ggplot(parent_pc1_load, aes(x = rank, y = cum_var)) +
  geom_line() +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
   annotate("text",
           x = idx_25_var,
           y = max(parent_pc1_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank",
    y = "Cumulative proportion of variance (loading^2)",
    title = "Parent PC1 cumulative variance contribution"
  ) +
  theme_classic()
dev.off()

#export a list of genes contributing 80% of variance to PC1
parent_pc1_important_25 <- parent_pc1_load %>%
  filter(rank <= idx_25_var)

write.csv(parent_pc1_important_25,
          "output/rna_seq/asca/parent_PC1_important_genes.csv",
          row.names = FALSE)

```














## Parent: PC2 

```{r}
# 1. Extract all loadings for PC2 (effect 2 = parent)
parent_pc2_raw <- get_loadings(res_all, effect = 2, component = 2)

# ALASCA usually returns a list; first element holds the data
if (is.list(parent_pc2_raw) && !inherits(parent_pc2_raw, "data.frame")) {
  parent_pc2_df <- as.data.frame(parent_pc2_raw[[1]])
} else {
  parent_pc2_df <- as.data.frame(parent_pc2_raw)
}

# Identify gene column and numeric loading column
# (You can change "covars" if your object uses a different name)
if (!"covars" %in% names(parent_pc2_df)) {
  stop("Could not find 'covars' column in PC2 loadings; check the structure of pc2_df.")
}

gene_vec <- parent_pc2_df$covars

num_cols <- names(parent_pc2_df)[sapply(parent_pc2_df, is.numeric)]

if (length(num_cols) == 0) {
  stop("No numeric loading column found in PC2 loadings.")
}
loading_col <- num_cols[2]  # typically the PC1 loading column

parent_pc2_load <- parent_pc2_df %>%
  transmute(
    gene    = gene_vec,
    loading = .data[[loading_col]]
  ) %>%
  mutate(
    abs_loading = abs(loading)
  ) %>%
  arrange(desc(abs_loading)) %>%
  mutate(
    rank           = row_number(),
    cum_abs        = cumsum(abs_loading),
    cum_abs_prop   = cum_abs / sum(abs_loading),
    var_contrib    = loading^2,
    cum_var        = cumsum(var_contrib) / sum(var_contrib)
  )

# 2. Find "elbow" on normalized abs(loadings) curve (Kneedle-style)
n <- nrow(parent_pc2_load)
x <- (parent_pc2_load$rank - 1) / (n - 1 + 1e-9)  # normalized rank
y <- (parent_pc2_load$abs_loading - min(parent_pc2_load$abs_loading)) /
     (max(parent_pc2_load$abs_loading) - min(parent_pc2_load$abs_loading) + 1e-9)

#elbow is selected at the rank of the maximum deviation between the loading curve and diagonal reference
diff_xy <- x - y
elbow_idx  <- which.max(diff_xy)
elbow_rank <- parent_pc2_load$rank[elbow_idx]
elbow_gene <- parent_pc2_load$gene[elbow_idx]

# 3. 25% cumulative variance threshold as a comparison
idx_25_var <- which(parent_pc2_load$cum_var >= 0.25)[1]

parent_pc2_load <- parent_pc2_load %>%
  mutate(
    selected_elbow  = rank <= elbow_rank,
    selected_25_var = rank <= idx_25_var
  )

cat("PC2 important genes by elbow selection: ",
    sum(parent_pc2_load$selected_elbow), "\n")
cat("PC2 important genes by 25% variance selection: ",
    sum(parent_pc2_load$selected_25_var), "\n")

# 5. Diagnostic plots ------------------------------------------

# (a) Absolute loadings vs rank, with elbow + 80% var lines
pdf("figures/rna_seq/asca/parent_PC2_abs_loadings_rank.pdf", width = 7, height = 5)
ggplot(parent_pc2_load, aes(x = rank, y = abs_loading)) +
  geom_line() +
  geom_point(size = 0.7) +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
  annotate("text",
           x = idx_25_var,
           y = max(parent_pc2_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank (sorted by |loading|)",
    y = "|PC2 loading|",
    title = "Parent PC2 absolute loadings and selection thresholds"
  ) +
  theme_classic()
dev.off()

# Cumulative proportion of variance (squared loadings)
pdf("figures/rna_seq/asca/parent_PC2_cumulative_variance.pdf", width = 7, height = 5)
ggplot(parent_pc2_load, aes(x = rank, y = cum_var)) +
  geom_line() +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
   annotate("text",
           x = idx_25_var,
           y = max(parent_pc2_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank",
    y = "Cumulative proportion of variance (loading^2)",
    title = "Parent PC2 cumulative variance contribution"
  ) +
  theme_classic()
dev.off()

#export a list of genes contributing 80% of variance to PC1
parent_pc2_important_25 <- parent_pc2_load %>%
  filter(rank <= idx_25_var)

write.csv(parent_pc2_important_25,
          "output/rna_seq/asca/parent_PC2_important_genes.csv",
          row.names = FALSE)
```

## ParentxTemperature: PC1 

```{r}
# 1. Extract all loadings for PC1 (effect 3 = parent:temperature)
int_pc1_raw <- get_loadings(res_all, effect = 3, component = 1)

# ALASCA usually returns a list; first element holds the data
if (is.list(int_pc1_raw) && !inherits(int_pc1_raw, "data.frame")) {
  int_pc1_df <- as.data.frame(int_pc1_raw[[1]])
} else {
  int_pc1_df <- as.data.frame(int_pc1_raw)
}

# Identify gene column and numeric loading column
# (You can change "covars" if your object uses a different name)
if (!"covars" %in% names(int_pc1_df)) {
  stop("Could not find 'covars' column in PC1 loadings; check the structure of pc1_df.")
}

gene_vec <- int_pc1_df$covars

num_cols <- names(int_pc1_df)[sapply(int_pc1_df, is.numeric)]

if (length(num_cols) == 0) {
  stop("No numeric loading column found in PC1 loadings.")
}
loading_col <- num_cols[2]  # typically the PC1 loading column

int_pc1_load <- int_pc1_df %>%
  transmute(
    gene    = gene_vec,
    loading = .data[[loading_col]]
  ) %>%
  mutate(
    abs_loading = abs(loading)
  ) %>%
  arrange(desc(abs_loading)) %>%
  mutate(
    rank           = row_number(),
    cum_abs        = cumsum(abs_loading),
    cum_abs_prop   = cum_abs / sum(abs_loading),
    var_contrib    = loading^2,
    cum_var        = cumsum(var_contrib) / sum(var_contrib)
  )

# 2. Find "elbow" on normalized abs(loadings) curve (Kneedle-style)
n <- nrow(int_pc1_load)
x <- (int_pc1_load$rank - 1) / (n - 1 + 1e-9)  # normalized rank
y <- (int_pc1_load$abs_loading - min(int_pc1_load$abs_loading)) /
     (max(int_pc1_load$abs_loading) - min(int_pc1_load$abs_loading) + 1e-9)

#elbow is selected at the rank of the maximum deviation between the loading curve and diagonal reference
diff_xy <- x - y
elbow_idx  <- which.max(diff_xy)
elbow_rank <- int_pc1_load$rank[elbow_idx]
elbow_gene <- int_pc1_load$gene[elbow_idx]

# 3. 25% cumulative variance threshold as a comparison
idx_25_var <- which(int_pc1_load$cum_var >= 0.25)[1]

int_pc1_load <- int_pc1_load %>%
  mutate(
    selected_elbow  = rank <= elbow_rank,
    selected_25_var = rank <= idx_25_var
  )

cat("PC1 important genes by elbow selection: ",
    sum(int_pc1_load$selected_elbow), "\n")
cat("PC1 important genes by 25% variance selection: ",
    sum(int_pc1_load$selected_25_var), "\n")

# 5. Diagnostic plots ------------------------------------------

# (a) Absolute loadings vs rank, with elbow + 80% var lines
pdf("figures/rna_seq/asca/interaction_PC1_abs_loadings_rank.pdf", width = 7, height = 5)
ggplot(int_pc1_load, aes(x = rank, y = abs_loading)) +
  geom_line() +
  geom_point(size = 0.7) +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
  annotate("text",
           x = idx_25_var,
           y = max(int_pc1_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank (sorted by |loading|)",
    y = "|PC1 loading|",
    title = "Interaction PC1 absolute loadings and selection thresholds"
  ) +
  theme_classic()
dev.off()

# Cumulative proportion of variance (squared loadings)
pdf("figures/rna_seq/asca/interaction_PC1_cumulative_variance.pdf", width = 7, height = 5)
ggplot(int_pc1_load, aes(x = rank, y = cum_var)) +
  geom_line() +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
   annotate("text",
           x = idx_25_var,
           y = max(int_pc1_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank",
    y = "Cumulative proportion of variance (loading^2)",
    title = "Interaction PC1 cumulative variance contribution"
  ) +
  theme_classic()
dev.off()

#export a list of genes contributing 80% of variance to PC1
int_pc1_important_25 <- int_pc1_load %>%
  filter(rank <= idx_25_var)

write.csv(int_pc1_important_25,
          "output/rna_seq/asca/interaction_PC1_important_genes.csv",
          row.names = FALSE)

```

## ParentxTemperature: PC2 

```{r}
# 1. Extract all loadings for PC1 (effect 3 = parent:temperature)
int_pc2_raw <- get_loadings(res_all, effect = 3, component = 2)

# ALASCA usually returns a list; first element holds the data
if (is.list(int_pc2_raw) && !inherits(int_pc2_raw, "data.frame")) {
  int_pc2_df <- as.data.frame(int_pc2_raw[[1]])
} else {
  int_pc2_df <- as.data.frame(int_pc2_raw)
}

# Identify gene column and numeric loading column
# (You can change "covars" if your object uses a different name)
if (!"covars" %in% names(int_pc2_df)) {
  stop("Could not find 'covars' column in PC2 loadings; check the structure of pc2_df.")
}

gene_vec <- int_pc2_df$covars

num_cols <- names(int_pc2_df)[sapply(int_pc2_df, is.numeric)]

if (length(num_cols) == 0) {
  stop("No numeric loading column found in PC2 loadings.")
}
loading_col <- num_cols[2]  # typically the PC1 loading column

int_pc2_load <- int_pc2_df %>%
  transmute(
    gene    = gene_vec,
    loading = .data[[loading_col]]
  ) %>%
  mutate(
    abs_loading = abs(loading)
  ) %>%
  arrange(desc(abs_loading)) %>%
  mutate(
    rank           = row_number(),
    cum_abs        = cumsum(abs_loading),
    cum_abs_prop   = cum_abs / sum(abs_loading),
    var_contrib    = loading^2,
    cum_var        = cumsum(var_contrib) / sum(var_contrib)
  )

# 2. Find "elbow" on normalized abs(loadings) curve (Kneedle-style)
n <- nrow(int_pc2_load)
x <- (int_pc2_load$rank - 1) / (n - 1 + 1e-9)  # normalized rank
y <- (int_pc2_load$abs_loading - min(int_pc2_load$abs_loading)) /
     (max(int_pc2_load$abs_loading) - min(int_pc2_load$abs_loading) + 1e-9)

#elbow is selected at the rank of the maximum deviation between the loading curve and diagonal reference
diff_xy <- x - y
elbow_idx  <- which.max(diff_xy)
elbow_rank <- int_pc2_load$rank[elbow_idx]
elbow_gene <- int_pc2_load$gene[elbow_idx]

# 3. 25% cumulative variance threshold as a comparison
idx_25_var <- which(int_pc2_load$cum_var >= 0.25)[1]

int_pc2_load <- int_pc2_load %>%
  mutate(
    selected_elbow  = rank <= elbow_rank,
    selected_25_var = rank <= idx_25_var
  )

cat("PC2 important genes by elbow selection: ",
    sum(int_pc2_load$selected_elbow), "\n")
cat("PC2 important genes by 25% variance selection: ",
    sum(int_pc2_load$selected_25_var), "\n")

# 5. Diagnostic plots ------------------------------------------

# (a) Absolute loadings vs rank, with elbow + 80% var lines
pdf("figures/rna_seq/asca/interaction_PC2_abs_loadings_rank.pdf", width = 7, height = 5)
ggplot(int_pc2_load, aes(x = rank, y = abs_loading)) +
  geom_line() +
  geom_point(size = 0.7) +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
  annotate("text",
           x = idx_25_var,
           y = max(int_pc2_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank (sorted by |loading|)",
    y = "|PC2 loading|",
    title = "Interaction PC2 absolute loadings and selection thresholds"
  ) +
  theme_classic()
dev.off()

# Cumulative proportion of variance (squared loadings)
pdf("figures/rna_seq/asca/interaction_PC2_cumulative_variance.pdf", width = 7, height = 5)
ggplot(int_pc2_load, aes(x = rank, y = cum_var)) +
  geom_line() +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
   annotate("text",
           x = idx_25_var,
           y = max(int_pc2_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank",
    y = "Cumulative proportion of variance (loading^2)",
    title = "Interaction PC2 cumulative variance contribution"
  ) +
  theme_classic()
dev.off()

#export a list of genes contributing 80% of variance to PC1
int_pc2_important_25 <- int_pc2_load %>%
  filter(rank <= idx_25_var)

write.csv(int_pc2_important_25,
          "output/rna_seq/asca/interaction_PC2_important_genes.csv",
          row.names = FALSE)

```

## ParentxTemperature: PC3 

```{r}
# 1. Extract all loadings for PC1 (effect 3 = parent:temperature)
int_pc3_raw <- get_loadings(res_all, effect = 3, component = 3)

# ALASCA usually returns a list; first element holds the data
if (is.list(int_pc3_raw) && !inherits(int_pc3_raw, "data.frame")) {
  int_pc3_df <- as.data.frame(int_pc3_raw[[1]])
} else {
  int_pc3_df <- as.data.frame(int_pc3_raw)
}

# Identify gene column and numeric loading column
# (You can change "covars" if your object uses a different name)
if (!"covars" %in% names(int_pc3_df)) {
  stop("Could not find 'covars' column in PC3 loadings; check the structure of pc3_df.")
}

gene_vec <- int_pc3_df$covars

num_cols <- names(int_pc3_df)[sapply(int_pc3_df, is.numeric)]

if (length(num_cols) == 0) {
  stop("No numeric loading column found in PC3 loadings.")
}
loading_col <- num_cols[2]  # typically the PC1 loading column

int_pc3_load <- int_pc3_df %>%
  transmute(
    gene    = gene_vec,
    loading = .data[[loading_col]]
  ) %>%
  mutate(
    abs_loading = abs(loading)
  ) %>%
  arrange(desc(abs_loading)) %>%
  mutate(
    rank           = row_number(),
    cum_abs        = cumsum(abs_loading),
    cum_abs_prop   = cum_abs / sum(abs_loading),
    var_contrib    = loading^2,
    cum_var        = cumsum(var_contrib) / sum(var_contrib)
  )

# 2. Find "elbow" on normalized abs(loadings) curve (Kneedle-style)
n <- nrow(int_pc3_load)
x <- (int_pc3_load$rank - 1) / (n - 1 + 1e-9)  # normalized rank
y <- (int_pc3_load$abs_loading - min(int_pc3_load$abs_loading)) /
     (max(int_pc3_load$abs_loading) - min(int_pc3_load$abs_loading) + 1e-9)

#elbow is selected at the rank of the maximum deviation between the loading curve and diagonal reference
diff_xy <- x - y
elbow_idx  <- which.max(diff_xy)
elbow_rank <- int_pc3_load$rank[elbow_idx]
elbow_gene <- int_pc3_load$gene[elbow_idx]

# 3. 25% cumulative variance threshold as a comparison
idx_25_var <- which(int_pc3_load$cum_var >= 0.25)[1]

int_pc3_load <- int_pc3_load %>%
  mutate(
    selected_elbow  = rank <= elbow_rank,
    selected_25_var = rank <= idx_25_var
  )

cat("PC3 important genes by elbow selection: ",
    sum(int_pc3_load$selected_elbow), "\n")
cat("PC3 important genes by 25% variance selection: ",
    sum(int_pc3_load$selected_25_var), "\n")

# 5. Diagnostic plots ------------------------------------------

# (a) Absolute loadings vs rank, with elbow + 80% var lines
pdf("figures/rna_seq/asca/interaction_PC3_abs_loadings_rank.pdf", width = 7, height = 5)
ggplot(int_pc3_load, aes(x = rank, y = abs_loading)) +
  geom_line() +
  geom_point(size = 0.7) +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
  annotate("text",
           x = idx_25_var,
           y = max(int_pc3_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank (sorted by |loading|)",
    y = "|PC3 loading|",
    title = "Interaction PC3 absolute loadings and selection thresholds"
  ) +
  theme_classic()
dev.off()

# Cumulative proportion of variance (squared loadings)
pdf("figures/rna_seq/asca/interaction_PC3_cumulative_variance.pdf", width = 7, height = 5)
ggplot(int_pc3_load, aes(x = rank, y = cum_var)) +
  geom_line() +
  geom_vline(xintercept = idx_25_var, linetype = "dashed") +
   annotate("text",
           x = idx_25_var,
           y = max(int_pc3_load$abs_loading) * 0.9,
           label = paste0("25% var (", idx_25_var, " genes)"),
           hjust = -0.1, vjust = 1) +
  labs(
    x = "Rank",
    y = "Cumulative proportion of variance (loading^2)",
    title = "Interaction PC3 cumulative variance contribution"
  ) +
  theme_classic()
dev.off()

#export a list of genes contributing 80% of variance to PC1
int_pc3_important_25 <- int_pc3_load %>%
  filter(rank <= idx_25_var)

write.csv(int_pc3_important_25,
          "output/rna_seq/asca/interaction_PC3_important_genes.csv",
          row.names = FALSE)

```

## Compare lists of lipids 

```{r}
temp_pc1_list<-temp_pc1_important_25%>%pull(gene)
temp_pc2_list<-temp_pc2_important_25%>%pull(gene)
parent_pc1_list<-parent_pc1_important_25%>%pull(gene)
parent_pc2_list<-parent_pc2_important_25%>%pull(gene)
int_pc1_list<-int_pc1_important_25%>%pull(gene)
int_pc2_list<-int_pc2_important_25%>%pull(gene)
int_pc3_list<-int_pc3_important_25%>%pull(gene)
```

```{r}
# install.packages("UpSetR")   # if needed
library(UpSetR)

# Create list object for upset
gene_lists <- list(
  temp_PC1 = temp_pc1_list,
  temp_PC2 = temp_pc2_list,
  parent_PC1 = parent_pc1_list,
  parent_PC2 = parent_pc2_list,
  int_PC1 = int_pc1_list,
  int_PC2 = int_pc2_list,
  int_PC3 = int_pc3_list
)

# Convert list to binary matrix for UpSetR
upset_data <- fromList(gene_lists)

colnames(upset_data)

# Plot
pdf("figures/rna_seq/asca/upset.pdf", width = 8, height = 6)
UpSetR::upset(upset_data,
      order.by = "freq",
      sets = c("temp_PC1", "temp_PC2", "parent_PC1", "parent_PC2", "int_PC1", "int_PC2", "int_PC3"),
      sets.bar.color = "black",
      mainbar.y.label = "Intersection size",
      sets.x.label = "Set size"
)
dev.off()
```

Most genes are unique to each PC, which means we have the strongest predictors of each PC. 

# Plot a heatmap of the most important lipids from each PC

```{r}
#make data frames for each PC
temp_pc1_important_25<-temp_pc1_important_25%>%mutate(PC="Temp 1")
temp_pc2_important_25<-temp_pc2_important_25%>%mutate(PC="Temp 2")
parent_pc1_important_25<-parent_pc1_important_25%>%mutate(PC="Parent 1")
parent_pc2_important_25<-parent_pc2_important_25%>%mutate(PC="Parent 2")
int_pc1_important_25<-int_pc1_important_25%>%mutate(PC="Interaction 1")
int_pc2_important_25<-int_pc2_important_25%>%mutate(PC="Interaction 2")
int_pc3_important_25<-int_pc3_important_25%>%mutate(PC="Interaction 3")

importance<-rbind(temp_pc1_important_25, temp_pc2_important_25, parent_pc1_important_25, parent_pc2_important_25, int_pc1_important_25, int_pc2_important_25, int_pc3_important_25)

importance<-importance%>%select(gene, abs_loading, var_contrib, PC)%>%rename(gene="variable")
head(importance)

#add in expression data 
pc_conc<-long_data%>%
  filter(variable %in% importance$variable)%>%
  left_join(., importance)

head(pc_conc)

test1<-levels(factor(importance$variable))
test2<-levels(factor(pc_conc$variable))
setdiff(test1, test2)
setdiff(test2, test1)

#save file to reuse later if needed 
write_csv(pc_conc, file="output/rna_seq/asca/important_genes_asca.csv")
```

## Temperature PC1 
```{r}
# Start from your original object
temp_pc1_conc <- pc_conc %>%
  filter(PC=="Temp 1")%>%
  mutate(
    sample   = as.character(sample),
    variable = as.character(variable),
    temperature = droplevels(temperature),
    parent      = droplevels(parent)
  )

mat_df <- temp_pc1_conc %>%
  select(variable, sample, value) %>%
  distinct() %>%
  pivot_wider(
    names_from  = sample,
    values_from = value,
    values_fill = list(value = NA_real_)
  ) %>%
  as.data.frame()   # <-- convert tibble → data.frame

rownames(mat_df) <- mat_df$variable
mat_df$variable  <- NULL

mat <- as.matrix(mat_df)

head(rownames(mat))  # should now show your lipid names
dim(mat)

# 3. Column annotation (temperature + parent) -----------------
col_annot <- temp_pc1_conc %>%
  distinct(sample, temperature, parent)

# Define desired sample order: by temperature, then parent, then sample ID
sample_order <- col_annot %>%
  arrange(temperature, parent, sample) %>%
  pull(sample) %>%
  unique()

# Make sure only samples that exist in the matrix are kept
sample_order <- sample_order[sample_order %in% colnames(mat)]
cat("Ordered samples:", length(sample_order), "\n")

if (length(sample_order) == 0) {
  stop("No overlap between samples in matrix and annotation – check sample IDs.")
}

# Apply manual column order
mat       <- mat[, sample_order, drop = FALSE]
col_annot <- col_annot %>%
  filter(sample %in% sample_order) %>%
  mutate(sample = factor(sample, levels = sample_order)) %>%
  arrange(sample)

# 4. Order rows by loading (highest at top) -------------------
row_order <- temp_pc1_conc %>%
  group_by(variable) %>%
  summarize(abs_loading = first(abs_loading), .groups = "drop") %>%
  arrange(desc(abs_loading)) %>%
  pull(variable)

row_order <- intersect(row_order, rownames(mat))
cat("Variables in row_order:", length(row_order), "\n")

if (length(row_order) == 0) {
  stop("No overlap between variables in loading table and matrix rownames.")
}

# Apply manual row order (y-axis)
mat <- mat[row_order, , drop = FALSE]

# 5. Annotation colors ----------------------------------------

# Explicit named colors for temperature
temp_cols <- c(
  "27"       = "#2c7bb6",
  "30" = "#7b3294",
  "33"     = "#d53e4f"
)

# Explicit named colors for parent
# Include a few possible variations for the 3rd level so it still works
parent_cols <- c(
  "Wildtype"    = "darkgray",
  "Bleached"    = "orange",
  "Nonbleached" = "darkred"
)

ha <- HeatmapAnnotation(
  Temperature = col_annot$temperature,
  Parent      = col_annot$parent,
  col = list(
    Temperature = temp_cols,
    Parent      = parent_cols
  )
)

# 6. Z-score by row (if not already done) ---------------------
# center & scale each row: (x - mean) / sd
row_means <- rowMeans(mat, na.rm = TRUE)
row_sds   <- apply(mat, 1, sd, na.rm = TRUE)

row_sds[row_sds == 0 | is.na(row_sds)] <- 1

mat_z <- sweep(mat, 1, row_means, FUN = "-")
mat_z <- sweep(mat_z, 1, row_sds,   FUN = "/")

# 7. Color scale for z-scores ---------------------------------
z_lim <- max(2, quantile(abs(mat_z[is.finite(mat_z)]), 0.95, na.rm = TRUE))

col_fun <- colorRamp2(
  c(-z_lim, 0, z_lim),
  c("navy", "white", "firebrick")
)

# 8. Complex heatmap (z-score, manual order, sample IDs shown) -
pdf("figures/rna_seq/asca/temp_PC1_heatmap.pdf", width = 9, height = 10)
Heatmap(
  mat_z,
  name = "Z-score",
  col  = col_fun,
  cluster_columns = FALSE,      # manual order, no dendrogram
  cluster_rows    = FALSE,
  column_split    = col_annot$temperature,   # <-- splits by temperature
  gap             = unit(3, "mm"),           # <-- spacing between temperature groups
  column_title    = "Temperature PC1 Effects",
  row_title       = "Variables (ordered by loading)",
  top_annotation  = ha,
  show_row_names    = FALSE,
  show_column_names = TRUE,
  row_names_gp       = gpar(fontsize = 6),
  column_names_gp    = gpar(fontsize = 6),
  column_names_rot   = 90
)
dev.off()
```

## Temperature PC2 
```{r}
# Start from your original object
temp_pc2_conc <- pc_conc %>%
  filter(PC=="Temp 2")%>%
  mutate(
    sample   = as.character(sample),
    variable = as.character(variable),
    temperature = droplevels(temperature),
    parent      = droplevels(parent)
  )

mat_df <- temp_pc2_conc %>%
  select(variable, sample, value) %>%
  distinct() %>%
  pivot_wider(
    names_from  = sample,
    values_from = value,
    values_fill = list(value = NA_real_)
  ) %>%
  as.data.frame()   # <-- convert tibble → data.frame

rownames(mat_df) <- mat_df$variable
mat_df$variable  <- NULL

mat <- as.matrix(mat_df)

head(rownames(mat))  # should now show your lipid names
dim(mat)

# 3. Column annotation (temperature + parent) -----------------
col_annot <- temp_pc2_conc %>%
  distinct(sample, temperature, parent)

# Define desired sample order: by temperature, then parent, then sample ID
sample_order <- col_annot %>%
  arrange(temperature, parent, sample) %>%
  pull(sample) %>%
  unique()

# Make sure only samples that exist in the matrix are kept
sample_order <- sample_order[sample_order %in% colnames(mat)]
cat("Ordered samples:", length(sample_order), "\n")

if (length(sample_order) == 0) {
  stop("No overlap between samples in matrix and annotation – check sample IDs.")
}

# Apply manual column order
mat       <- mat[, sample_order, drop = FALSE]
col_annot <- col_annot %>%
  filter(sample %in% sample_order) %>%
  mutate(sample = factor(sample, levels = sample_order)) %>%
  arrange(sample)

# 4. Order rows by loading (highest at top) -------------------
row_order <- temp_pc2_conc %>%
  group_by(variable) %>%
  summarize(abs_loading = first(abs_loading), .groups = "drop") %>%
  arrange(desc(abs_loading)) %>%
  pull(variable)

row_order <- intersect(row_order, rownames(mat))
cat("Variables in row_order:", length(row_order), "\n")

if (length(row_order) == 0) {
  stop("No overlap between variables in loading table and matrix rownames.")
}

# Apply manual row order (y-axis)
mat <- mat[row_order, , drop = FALSE]

# 5. Annotation colors ----------------------------------------

# Explicit named colors for temperature
temp_cols <- c(
  "27"       = "#2c7bb6",
  "30" = "#7b3294",
  "33"     = "#d53e4f"
)

# Explicit named colors for parent
# Include a few possible variations for the 3rd level so it still works
parent_cols <- c(
  "Wildtype"    = "darkgray",
  "Bleached"    = "orange",
  "Nonbleached" = "darkred"
)

ha <- HeatmapAnnotation(
  Temperature = col_annot$temperature,
  Parent      = col_annot$parent,
  col = list(
    Temperature = temp_cols,
    Parent      = parent_cols
  )
)

# 6. Z-score by row (if not already done) ---------------------
# center & scale each row: (x - mean) / sd
row_means <- rowMeans(mat, na.rm = TRUE)
row_sds   <- apply(mat, 1, sd, na.rm = TRUE)

row_sds[row_sds == 0 | is.na(row_sds)] <- 1

mat_z <- sweep(mat, 1, row_means, FUN = "-")
mat_z <- sweep(mat_z, 1, row_sds,   FUN = "/")

# 7. Color scale for z-scores ---------------------------------
z_lim <- max(2, quantile(abs(mat_z[is.finite(mat_z)]), 0.95, na.rm = TRUE))

col_fun <- colorRamp2(
  c(-z_lim, 0, z_lim),
  c("navy", "white", "firebrick")
)

# 8. Complex heatmap (z-score, manual order, sample IDs shown) -
pdf("figures/rna_seq/asca/temp_PC2_heatmap.pdf", width = 8, height = 9)
Heatmap(
  mat_z,
  name = "Z-score",
  col  = col_fun,
  cluster_columns = FALSE,      # manual order, no dendrogram
  cluster_rows    = FALSE,
  column_split    = col_annot$temperature,   # <-- splits by temperature
  gap             = unit(3, "mm"),           # <-- spacing between temperature groups
  column_title    = "Temperature PC2 Effects",
  row_title       = "Variables (ordered by loading)",
  top_annotation  = ha,
  show_row_names    = FALSE,
  show_column_names = TRUE,
  row_names_gp       = gpar(fontsize = 6),
  column_names_gp    = gpar(fontsize = 6),
  column_names_rot   = 90
)
dev.off()
```

## Parent PC1 
```{r}
# Start from your original object
parent_pc1_conc <- pc_conc %>%
  filter(PC=="Parent 1")%>%
  mutate(
    sample   = as.character(sample),
    variable = as.character(variable),
    temperature = droplevels(temperature),
    parent      = droplevels(parent)
  )

mat_df <- parent_pc1_conc %>%
  select(variable, sample, value) %>%
  distinct() %>%
  pivot_wider(
    names_from  = sample,
    values_from = value,
    values_fill = list(value = NA_real_)
  ) %>%
  as.data.frame()   # <-- convert tibble → data.frame

rownames(mat_df) <- mat_df$variable
mat_df$variable  <- NULL

mat <- as.matrix(mat_df)

head(rownames(mat))  # should now show your lipid names
dim(mat)

# 3. Column annotation (temperature + parent) -----------------
col_annot <- parent_pc1_conc %>%
  distinct(sample, temperature, parent)

# Define desired sample order: by temperature, then parent, then sample ID
sample_order <- col_annot %>%
  arrange(temperature, parent, sample) %>%
  pull(sample) %>%
  unique()

# Make sure only samples that exist in the matrix are kept
sample_order <- sample_order[sample_order %in% colnames(mat)]
cat("Ordered samples:", length(sample_order), "\n")

if (length(sample_order) == 0) {
  stop("No overlap between samples in matrix and annotation – check sample IDs.")
}

# Apply manual column order
mat       <- mat[, sample_order, drop = FALSE]
col_annot <- col_annot %>%
  filter(sample %in% sample_order) %>%
  mutate(sample = factor(sample, levels = sample_order)) %>%
  arrange(sample)

# 4. Order rows by loading (highest at top) -------------------
row_order <- parent_pc1_conc %>%
  group_by(variable) %>%
  summarize(abs_loading = first(abs_loading), .groups = "drop") %>%
  arrange(desc(abs_loading)) %>%
  pull(variable)

row_order <- intersect(row_order, rownames(mat))
cat("Variables in row_order:", length(row_order), "\n")

if (length(row_order) == 0) {
  stop("No overlap between variables in loading table and matrix rownames.")
}

# Apply manual row order (y-axis)
mat <- mat[row_order, , drop = FALSE]

# 5. Annotation colors ----------------------------------------

# Explicit named colors for temperature
temp_cols <- c(
  "27"       = "#2c7bb6",
  "30" = "#7b3294",
  "33"     = "#d53e4f"
)

# Explicit named colors for parent
# Include a few possible variations for the 3rd level so it still works
parent_cols <- c(
  "Wildtype"    = "darkgray",
  "Bleached"    = "orange",
  "Nonbleached" = "darkred"
)

ha <- HeatmapAnnotation(
  Temperature = col_annot$temperature,
  Parent      = col_annot$parent,
  col = list(
    Temperature = temp_cols,
    Parent      = parent_cols
  )
)

# 6. Z-score by row (if not already done) ---------------------
# center & scale each row: (x - mean) / sd
row_means <- rowMeans(mat, na.rm = TRUE)
row_sds   <- apply(mat, 1, sd, na.rm = TRUE)

row_sds[row_sds == 0 | is.na(row_sds)] <- 1

mat_z <- sweep(mat, 1, row_means, FUN = "-")
mat_z <- sweep(mat_z, 1, row_sds,   FUN = "/")

# 7. Color scale for z-scores ---------------------------------
z_lim <- max(2, quantile(abs(mat_z[is.finite(mat_z)]), 0.95, na.rm = TRUE))

col_fun <- colorRamp2(
  c(-z_lim, 0, z_lim),
  c("navy", "white", "firebrick")
)

# 8. Complex heatmap (z-score, manual order, sample IDs shown) -
pdf("figures/rna_seq/asca/parent_PC1_heatmap.pdf", width = 9, height = 9)
Heatmap(
  mat_z,
  name = "Z-score",
  col  = col_fun,
  cluster_columns = FALSE,      # manual order, no dendrogram
  cluster_rows    = FALSE,
  column_split    = col_annot$parent,   # <-- splits by temperature
  gap             = unit(3, "mm"),           # <-- spacing between temperature groups
  column_title    = "Parent PC1 Effects",
  row_title       = "Variables (ordered by loading)",
  top_annotation  = ha,
  show_row_names    = FALSE,
  show_column_names = TRUE,
  row_names_gp       = gpar(fontsize = 6),
  column_names_gp    = gpar(fontsize = 6),
  column_names_rot   = 90
)
dev.off()
```

## Parent PC2 
```{r}
# Start from your original object
parent_pc2_conc <- pc_conc %>%
  filter(PC=="Parent 2")%>%
  mutate(
    sample   = as.character(sample),
    variable = as.character(variable),
    temperature = droplevels(temperature),
    parent      = droplevels(parent)
  )

mat_df <- parent_pc2_conc %>%
  select(variable, sample, value) %>%
  distinct() %>%
  pivot_wider(
    names_from  = sample,
    values_from = value,
    values_fill = list(value = NA_real_)
  ) %>%
  as.data.frame()   # <-- convert tibble → data.frame

rownames(mat_df) <- mat_df$variable
mat_df$variable  <- NULL

mat <- as.matrix(mat_df)

head(rownames(mat))  # should now show your lipid names
dim(mat)

# 3. Column annotation (temperature + parent) -----------------
col_annot <- parent_pc2_conc %>%
  distinct(sample, temperature, parent)

# Define desired sample order: by temperature, then parent, then sample ID
sample_order <- col_annot %>%
  arrange(temperature, parent, sample) %>%
  pull(sample) %>%
  unique()

# Make sure only samples that exist in the matrix are kept
sample_order <- sample_order[sample_order %in% colnames(mat)]
cat("Ordered samples:", length(sample_order), "\n")

if (length(sample_order) == 0) {
  stop("No overlap between samples in matrix and annotation – check sample IDs.")
}

# Apply manual column order
mat       <- mat[, sample_order, drop = FALSE]
col_annot <- col_annot %>%
  filter(sample %in% sample_order) %>%
  mutate(sample = factor(sample, levels = sample_order)) %>%
  arrange(sample)

# 4. Order rows by loading (highest at top) -------------------
row_order <- parent_pc2_conc %>%
  group_by(variable) %>%
  summarize(abs_loading = first(abs_loading), .groups = "drop") %>%
  arrange(desc(abs_loading)) %>%
  pull(variable)

row_order <- intersect(row_order, rownames(mat))
cat("Variables in row_order:", length(row_order), "\n")

if (length(row_order) == 0) {
  stop("No overlap between variables in loading table and matrix rownames.")
}

# Apply manual row order (y-axis)
mat <- mat[row_order, , drop = FALSE]

# 5. Annotation colors ----------------------------------------

# Explicit named colors for temperature
temp_cols <- c(
  "27"       = "#2c7bb6",
  "30" = "#7b3294",
  "33"     = "#d53e4f"
)

# Explicit named colors for parent
# Include a few possible variations for the 3rd level so it still works
parent_cols <- c(
  "Wildtype"    = "darkgray",
  "Bleached"    = "orange",
  "Nonbleached" = "darkred"
)

ha <- HeatmapAnnotation(
  Temperature = col_annot$temperature,
  Parent      = col_annot$parent,
  col = list(
    Temperature = temp_cols,
    Parent      = parent_cols
  )
)

# 6. Z-score by row (if not already done) ---------------------
# center & scale each row: (x - mean) / sd
row_means <- rowMeans(mat, na.rm = TRUE)
row_sds   <- apply(mat, 1, sd, na.rm = TRUE)

row_sds[row_sds == 0 | is.na(row_sds)] <- 1

mat_z <- sweep(mat, 1, row_means, FUN = "-")
mat_z <- sweep(mat_z, 1, row_sds,   FUN = "/")

# 7. Color scale for z-scores ---------------------------------
z_lim <- max(2, quantile(abs(mat_z[is.finite(mat_z)]), 0.95, na.rm = TRUE))

col_fun <- colorRamp2(
  c(-z_lim, 0, z_lim),
  c("navy", "white", "firebrick")
)

# 8. Complex heatmap (z-score, manual order, sample IDs shown) -
pdf("figures/rna_seq/asca/parent_PC2_heatmap.pdf", width = 9, height = 9)
Heatmap(
  mat_z,
  name = "Z-score",
  col  = col_fun,
  cluster_columns = FALSE,      # manual order, no dendrogram
  cluster_rows    = FALSE,
  column_split    = col_annot$parent,   # <-- splits by temperature
  gap             = unit(3, "mm"),           # <-- spacing between temperature groups
  column_title    = "Parent PC2 Effects",
  row_title       = "Variables (ordered by loading)",
  top_annotation  = ha,
  show_row_names    = FALSE,
  show_column_names = TRUE,
  row_names_gp       = gpar(fontsize = 6),
  column_names_gp    = gpar(fontsize = 6),
  column_names_rot   = 90
)
dev.off()
```

## Interaction PC1 
```{r}
# Start from your original object
int_pc1_conc <- pc_conc %>%
  filter(PC=="Interaction 1")%>%
  mutate(
    sample   = as.character(sample),
    variable = as.character(variable),
    temperature = droplevels(temperature),
    parent      = droplevels(parent)
  )

mat_df <- int_pc1_conc %>%
  select(variable, sample, value) %>%
  distinct() %>%
  pivot_wider(
    names_from  = sample,
    values_from = value,
    values_fill = list(value = NA_real_)
  ) %>%
  as.data.frame()   # <-- convert tibble → data.frame

rownames(mat_df) <- mat_df$variable
mat_df$variable  <- NULL

mat <- as.matrix(mat_df)

head(rownames(mat))  # should now show your lipid names
dim(mat)

# 3. Column annotation (temperature + parent) -----------------
col_annot <- int_pc1_conc %>%
  distinct(sample, temperature, parent)

# Define desired sample order: by temperature, then parent, then sample ID
sample_order <- col_annot %>%
  arrange(temperature, parent, sample) %>%
  pull(sample) %>%
  unique()

# Make sure only samples that exist in the matrix are kept
sample_order <- sample_order[sample_order %in% colnames(mat)]
cat("Ordered samples:", length(sample_order), "\n")

if (length(sample_order) == 0) {
  stop("No overlap between samples in matrix and annotation – check sample IDs.")
}

# Apply manual column order
mat       <- mat[, sample_order, drop = FALSE]
col_annot <- col_annot %>%
  filter(sample %in% sample_order) %>%
  mutate(sample = factor(sample, levels = sample_order)) %>%
  arrange(sample)

# 4. Order rows by loading (highest at top) -------------------
row_order <- int_pc1_conc %>%
  group_by(variable) %>%
  summarize(abs_loading = first(abs_loading), .groups = "drop") %>%
  arrange(desc(abs_loading)) %>%
  pull(variable)

row_order <- intersect(row_order, rownames(mat))
cat("Variables in row_order:", length(row_order), "\n")

if (length(row_order) == 0) {
  stop("No overlap between variables in loading table and matrix rownames.")
}

# Apply manual row order (y-axis)
mat <- mat[row_order, , drop = FALSE]

# 5. Annotation colors ----------------------------------------

# Explicit named colors for temperature
temp_cols <- c(
  "27"       = "#2c7bb6",
  "30" = "#7b3294",
  "33"     = "#d53e4f"
)

# Explicit named colors for parent
# Include a few possible variations for the 3rd level so it still works
parent_cols <- c(
  "Wildtype"    = "darkgray",
  "Bleached"    = "orange",
  "Nonbleached" = "darkred"
)

ha <- HeatmapAnnotation(
  Temperature = col_annot$temperature,
  Parent      = col_annot$parent,
  col = list(
    Temperature = temp_cols,
    Parent      = parent_cols
  )
)

# 6. Z-score by row (if not already done) ---------------------
# center & scale each row: (x - mean) / sd
row_means <- rowMeans(mat, na.rm = TRUE)
row_sds   <- apply(mat, 1, sd, na.rm = TRUE)

row_sds[row_sds == 0 | is.na(row_sds)] <- 1

mat_z <- sweep(mat, 1, row_means, FUN = "-")
mat_z <- sweep(mat_z, 1, row_sds,   FUN = "/")

# 7. Color scale for z-scores ---------------------------------
z_lim <- max(2, quantile(abs(mat_z[is.finite(mat_z)]), 0.95, na.rm = TRUE))

col_fun <- colorRamp2(
  c(-z_lim, 0, z_lim),
  c("navy", "white", "firebrick")
)

# 8. Complex heatmap (z-score, manual order, sample IDs shown) -
pdf("figures/rna_seq/asca/interaction_PC1_heatmap.pdf", width = 9, height = 9)
Heatmap(
  mat_z,
  name = "Z-score",
  col  = col_fun,
  cluster_columns = FALSE,      # manual order, no dendrogram
  cluster_rows    = FALSE,
  column_split    = col_annot$temperature,   # <-- splits by temperature
  gap             = unit(3, "mm"),           # <-- spacing between temperature groups
  column_title    = "Interaction PC1 Effects",
  row_title       = "Variables (ordered by loading)",
  top_annotation  = ha,
  show_row_names    = FALSE,
  show_column_names = TRUE,
  row_names_gp       = gpar(fontsize = 6),
  column_names_gp    = gpar(fontsize = 6),
  column_names_rot   = 90
)
dev.off()
```

## Interaction PC2 
```{r}
# Start from your original object
int_pc2_conc <- pc_conc %>%
  filter(PC=="Interaction 2")%>%
  mutate(
    sample   = as.character(sample),
    variable = as.character(variable),
    temperature = droplevels(temperature),
    parent      = droplevels(parent)
  )

mat_df <- int_pc2_conc %>%
  select(variable, sample, value) %>%
  distinct() %>%
  pivot_wider(
    names_from  = sample,
    values_from = value,
    values_fill = list(value = NA_real_)
  ) %>%
  as.data.frame()   # <-- convert tibble → data.frame

rownames(mat_df) <- mat_df$variable
mat_df$variable  <- NULL

mat <- as.matrix(mat_df)

head(rownames(mat))  # should now show your lipid names
dim(mat)

# 3. Column annotation (temperature + parent) -----------------
col_annot <- int_pc2_conc %>%
  distinct(sample, temperature, parent)

# Define desired sample order: by temperature, then parent, then sample ID
sample_order <- col_annot %>%
  arrange(temperature, parent, sample) %>%
  pull(sample) %>%
  unique()

# Make sure only samples that exist in the matrix are kept
sample_order <- sample_order[sample_order %in% colnames(mat)]
cat("Ordered samples:", length(sample_order), "\n")

if (length(sample_order) == 0) {
  stop("No overlap between samples in matrix and annotation – check sample IDs.")
}

# Apply manual column order
mat       <- mat[, sample_order, drop = FALSE]
col_annot <- col_annot %>%
  filter(sample %in% sample_order) %>%
  mutate(sample = factor(sample, levels = sample_order)) %>%
  arrange(sample)

# 4. Order rows by loading (highest at top) -------------------
row_order <- int_pc2_conc %>%
  group_by(variable) %>%
  summarize(abs_loading = first(abs_loading), .groups = "drop") %>%
  arrange(desc(abs_loading)) %>%
  pull(variable)

row_order <- intersect(row_order, rownames(mat))
cat("Variables in row_order:", length(row_order), "\n")

if (length(row_order) == 0) {
  stop("No overlap between variables in loading table and matrix rownames.")
}

# Apply manual row order (y-axis)
mat <- mat[row_order, , drop = FALSE]

# 5. Annotation colors ----------------------------------------

# Explicit named colors for temperature
temp_cols <- c(
  "27"       = "#2c7bb6",
  "30" = "#7b3294",
  "33"     = "#d53e4f"
)

# Explicit named colors for parent
# Include a few possible variations for the 3rd level so it still works
parent_cols <- c(
  "Wildtype"    = "darkgray",
  "Bleached"    = "orange",
  "Nonbleached" = "darkred"
)

ha <- HeatmapAnnotation(
  Temperature = col_annot$temperature,
  Parent      = col_annot$parent,
  col = list(
    Temperature = temp_cols,
    Parent      = parent_cols
  )
)

# 6. Z-score by row (if not already done) ---------------------
# center & scale each row: (x - mean) / sd
row_means <- rowMeans(mat, na.rm = TRUE)
row_sds   <- apply(mat, 1, sd, na.rm = TRUE)

row_sds[row_sds == 0 | is.na(row_sds)] <- 1

mat_z <- sweep(mat, 1, row_means, FUN = "-")
mat_z <- sweep(mat_z, 1, row_sds,   FUN = "/")

# 7. Color scale for z-scores ---------------------------------
z_lim <- max(2, quantile(abs(mat_z[is.finite(mat_z)]), 0.95, na.rm = TRUE))

col_fun <- colorRamp2(
  c(-z_lim, 0, z_lim),
  c("navy", "white", "firebrick")
)

# 8. Complex heatmap (z-score, manual order, sample IDs shown) -
pdf("figures/rna_seq/asca/interaction_PC2_heatmap.pdf", width = 9, height = 9)
Heatmap(
  mat_z,
  name = "Z-score",
  col  = col_fun,
  cluster_columns = FALSE,      # manual order, no dendrogram
  cluster_rows    = FALSE,
  column_split    = col_annot$temperature,   # <-- splits by temperature
  gap             = unit(3, "mm"),           # <-- spacing between temperature groups
  column_title    = "Interaction PC2 Effects",
  row_title       = "Variables (ordered by loading)",
  top_annotation  = ha,
  show_row_names    = FALSE,
  show_column_names = TRUE,
  row_names_gp       = gpar(fontsize = 6),
  column_names_gp    = gpar(fontsize = 6),
  column_names_rot   = 90
)
dev.off()
```











## Interaction PC3 
```{r}
# Start from your original object
int_pc3_conc <- pc_conc %>%
  filter(PC=="Interaction 3")%>%
  mutate(
    sample   = as.character(sample),
    variable = as.character(variable),
    temperature = droplevels(temperature),
    parent      = droplevels(parent)
  )

mat_df <- int_pc3_conc %>%
  select(variable, sample, value) %>%
  distinct() %>%
  pivot_wider(
    names_from  = sample,
    values_from = value,
    values_fill = list(value = NA_real_)
  ) %>%
  as.data.frame()   # <-- convert tibble → data.frame

rownames(mat_df) <- mat_df$variable
mat_df$variable  <- NULL

mat <- as.matrix(mat_df)

head(rownames(mat))  # should now show your lipid names
dim(mat)

# 3. Column annotation (temperature + parent) -----------------
col_annot <- int_pc3_conc %>%
  distinct(sample, temperature, parent)

# Define desired sample order: by temperature, then parent, then sample ID
sample_order <- col_annot %>%
  arrange(temperature, parent, sample) %>%
  pull(sample) %>%
  unique()

# Make sure only samples that exist in the matrix are kept
sample_order <- sample_order[sample_order %in% colnames(mat)]
cat("Ordered samples:", length(sample_order), "\n")

if (length(sample_order) == 0) {
  stop("No overlap between samples in matrix and annotation – check sample IDs.")
}

# Apply manual column order
mat       <- mat[, sample_order, drop = FALSE]
col_annot <- col_annot %>%
  filter(sample %in% sample_order) %>%
  mutate(sample = factor(sample, levels = sample_order)) %>%
  arrange(sample)

# 4. Order rows by loading (highest at top) -------------------
row_order <- int_pc3_conc %>%
  group_by(variable) %>%
  summarize(abs_loading = first(abs_loading), .groups = "drop") %>%
  arrange(desc(abs_loading)) %>%
  pull(variable)

row_order <- intersect(row_order, rownames(mat))
cat("Variables in row_order:", length(row_order), "\n")

if (length(row_order) == 0) {
  stop("No overlap between variables in loading table and matrix rownames.")
}

# Apply manual row order (y-axis)
mat <- mat[row_order, , drop = FALSE]

# 5. Annotation colors ----------------------------------------

# Explicit named colors for temperature
temp_cols <- c(
  "27"       = "#2c7bb6",
  "30" = "#7b3294",
  "33"     = "#d53e4f"
)

# Explicit named colors for parent
# Include a few possible variations for the 3rd level so it still works
parent_cols <- c(
  "Wildtype"    = "darkgray",
  "Bleached"    = "orange",
  "Nonbleached" = "darkred"
)

ha <- HeatmapAnnotation(
  Temperature = col_annot$temperature,
  Parent      = col_annot$parent,
  col = list(
    Temperature = temp_cols,
    Parent      = parent_cols
  )
)

# 6. Z-score by row (if not already done) ---------------------
# center & scale each row: (x - mean) / sd
row_means <- rowMeans(mat, na.rm = TRUE)
row_sds   <- apply(mat, 1, sd, na.rm = TRUE)

row_sds[row_sds == 0 | is.na(row_sds)] <- 1

mat_z <- sweep(mat, 1, row_means, FUN = "-")
mat_z <- sweep(mat_z, 1, row_sds,   FUN = "/")

# 7. Color scale for z-scores ---------------------------------
z_lim <- max(2, quantile(abs(mat_z[is.finite(mat_z)]), 0.95, na.rm = TRUE))

col_fun <- colorRamp2(
  c(-z_lim, 0, z_lim),
  c("navy", "white", "firebrick")
)

# 8. Complex heatmap (z-score, manual order, sample IDs shown) -
pdf("figures/rna_seq/asca/interaction_PC3_heatmap.pdf", width = 9, height = 9)
Heatmap(
  mat_z,
  name = "Z-score",
  col  = col_fun,
  cluster_columns = FALSE,      # manual order, no dendrogram
  cluster_rows    = FALSE,
  column_split    = col_annot$temperature,   # <-- splits by temperature
  gap             = unit(3, "mm"),           # <-- spacing between temperature groups
  column_title    = "Interaction PC3 Effects",
  row_title       = "Variables (ordered by loading)",
  top_annotation  = ha,
  show_row_names    = FALSE,
  show_column_names = TRUE,
  row_names_gp       = gpar(fontsize = 6),
  column_names_gp    = gpar(fontsize = 6),
  column_names_rot   = 90
)
dev.off()
```

# Plot top 12 contributing genes on each component 

Temperature PC1 
```{r}
temp_cols <- c(
  "27"       = "#2c7bb6",
  "30" = "#7b3294",
  "33"     = "#d53e4f"
)

top10_temp_pc1<-pc_conc%>%
  filter(PC=="Temp 1")%>%
  arrange(desc(abs_loading))%>%
  select(variable, abs_loading)%>%
  unique()%>%
  slice_head(n=12)%>%
  pull(variable)

pc_plot1<-pc_conc%>%
  filter(variable %in% top10_temp_pc1)%>%
  
  ggplot(aes(x=temperature, y=value, colour=temperature))+
  facet_wrap(~variable, scales="free_y")+
  geom_boxplot(outliers=FALSE)+
  geom_point(position=position_dodge(0.8))+
  scale_colour_manual(name="Temperature", values=temp_cols)+
  ggtitle("Temperature PC1 Effects")+
  xlab("Temperature")+
  ylab("Expression")+
  theme_classic()+
  theme(axis.text.x = element_text(angle=45, hjust=1));pc_plot1
  
ggsave(pc_plot1, filename="figures/rna_seq/asca/Temp_PC1_top10_genes.png", height=6, width=12)
```

Temperature PC2
```{r}
top10_temp_pc2<-pc_conc%>%
  filter(PC=="Temp 2")%>%
  arrange(desc(abs_loading))%>%
  select(variable, abs_loading)%>%
  unique()%>%
  slice_head(n=12)%>%
  pull(variable)

pc_plot2<-pc_conc%>%
  filter(variable %in% top10_temp_pc2)%>%
  
  ggplot(aes(x=temperature, y=value, colour=temperature))+
  facet_wrap(~variable, scales="free_y")+
  geom_boxplot(outliers=FALSE)+
  geom_point(position=position_dodge(0.8))+
  scale_colour_manual(name="Temperature", values=temp_cols)+
  ggtitle("Temperature PC2 Effects")+
  xlab("Temperature")+
  ylab("Expression")+
  theme_classic()+
  theme(axis.text.x = element_text(angle=45, hjust=1));pc_plot2
  
ggsave(pc_plot2, filename="figures/rna_seq/asca/Temp_PC2_top10_genes.png", height=6, width=12)
```

Parent PC1
```{r}
parent_cols <- c(
  "Wildtype"    = "darkgray",
  "Bleached"    = "orange",
  "Nonbleached" = "darkred"
)

parent_labels <-c(
  "Wildtype" = "Wildtype (C/D)", 
  "Bleached" = "Sensitive (C)", 
  "Nonbleached" = "Resistant (C/D)"
)

top10_parent_pc1<-pc_conc%>%
  filter(PC=="Parent 1")%>%
  arrange(desc(abs_loading))%>%
  select(variable, abs_loading)%>%
  unique()%>%
  slice_head(n=12)%>%
  pull(variable)

pc_plot3<-pc_conc%>%
  filter(variable %in% top10_parent_pc1)%>%
  
  ggplot(aes(x=temperature, y=value, colour=parent))+
  facet_wrap(~variable, scales="free_y")+
  geom_boxplot(outliers=FALSE)+
  geom_point(position=position_dodge(0.8))+
  scale_colour_manual(name="Phenotype", values=parent_cols, labels=parent_labels)+
  ggtitle("Parent PC1 Effects")+
  xlab("Temperature")+
  ylab("Expression")+
  theme_classic()+
  theme(axis.text.x = element_text(angle=45, hjust=1));pc_plot3
  
ggsave(pc_plot3, filename="figures/rna_seq/asca/Parent_PC1_top10_genes.png", height=6, width=12)
```

Parent PC2
```{r}
top10_parent_pc2<-pc_conc%>%
  filter(PC=="Parent 2")%>%
  arrange(desc(abs_loading))%>%
  select(variable, abs_loading)%>%
  unique()%>%
  slice_head(n=12)%>%
  pull(variable)

pc_plot4<-pc_conc%>%
  filter(variable %in% top10_parent_pc2)%>%
  
  ggplot(aes(x=temperature, y=value, colour=parent))+
  facet_wrap(~variable, scales="free_y")+
  geom_boxplot(outliers=FALSE)+
  geom_point(position=position_dodge(0.8))+
  scale_colour_manual(name="Phenotype", values=parent_cols, labels=parent_labels)+
  ggtitle("Parent PC2 Effects")+
  xlab("Temperature")+
  ylab("Expression")+
  theme_classic()+
  theme(axis.text.x = element_text(angle=45, hjust=1));pc_plot4
  
ggsave(pc_plot4, filename="figures/rna_seq/asca/Parent_PC2_top10_genes.png", height=6, width=12)
```

Interaction PC1
```{r}
top10_int_pc1<-pc_conc%>%
  filter(PC=="Interaction 1")%>%
  arrange(desc(abs_loading))%>%
  select(variable, abs_loading)%>%
  unique()%>%
  slice_head(n=12)%>%
  pull(variable)

pc_plot5<-pc_conc%>%
  filter(variable %in% top10_int_pc1)%>%
  
  ggplot(aes(x=temperature, y=value, colour=parent))+
  facet_wrap(~variable, scales="free_y")+
  geom_boxplot(outliers=FALSE)+
  geom_point(position=position_dodge(0.8))+
  scale_colour_manual(name="Phenotype", values=parent_cols, labels=parent_labels)+
  ggtitle("Interaction PC1 Effects")+
  xlab("Temperature")+
  ylab("Expression")+
  theme_classic()+
  theme(axis.text.x = element_text(angle=45, hjust=1));pc_plot5
  
ggsave(pc_plot5, filename="figures/rna_seq/asca/Interaction_PC1_top10_genes.png", height=6, width=12)
```

Interaction PC2
```{r}
top10_int_pc2<-pc_conc%>%
  filter(PC=="Interaction 2")%>%
  arrange(desc(abs_loading))%>%
  select(variable, abs_loading)%>%
  unique()%>%
  slice_head(n=12)%>%
  pull(variable)

pc_plot6<-pc_conc%>%
  filter(variable %in% top10_int_pc2)%>%
  
  ggplot(aes(x=temperature, y=value, colour=parent))+
  facet_wrap(~variable, scales="free_y")+
  geom_boxplot(outliers=FALSE)+
  geom_point(position=position_dodge(0.8))+
  scale_colour_manual(name="Phenotype", values=parent_cols, labels=parent_labels)+
  ggtitle("Interaction PC2 Effects")+
  xlab("Temperature")+
  ylab("Expression")+
  theme_classic()+
  theme(axis.text.x = element_text(angle=45, hjust=1));pc_plot6
  
ggsave(pc_plot6, filename="figures/rna_seq/asca/Interaction_PC2_top10_genes.png", height=6, width=12)
```

Interaction PC3
```{r}
top10_int_pc3<-pc_conc%>%
  filter(PC=="Interaction 3")%>%
  arrange(desc(abs_loading))%>%
  select(variable, abs_loading)%>%
  unique()%>%
  slice_head(n=12)%>%
  pull(variable)

pc_plot7<-pc_conc%>%
  filter(variable %in% top10_int_pc3)%>%
  
  ggplot(aes(x=temperature, y=value, colour=parent))+
  facet_wrap(~variable, scales="free_y")+
  geom_boxplot(outliers=FALSE)+
  geom_point(position=position_dodge(0.8))+
  scale_colour_manual(name="Phenotype", values=parent_cols, labels=parent_labels)+
  ggtitle("Interaction PC3 Effects")+
  xlab("Temperature")+
  ylab("Expression")+
  theme_classic()+
  theme(axis.text.x = element_text(angle=45, hjust=1));pc_plot7
  
ggsave(pc_plot7, filename="figures/rna_seq/asca/Interaction_PC3_top10_genes.png", height=6, width=12)
```


