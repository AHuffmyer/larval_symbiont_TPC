---
title: "Larval Photosynthesis Rates Extraction with LoLinR - Hawaii 2023 - Temp x Light Measurements"
author: "AS Huffmyer"
date: '2023'
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_depth: 6
    toc_float: yes
  pdf_document:
    keep_tex: yes
editor_options: 
  chunk_output_type: console
---

## Setup  

Set up workspace, set options, and load required packages.    
```{r}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r, warning=FALSE, message=FALSE}
## install packages if you dont already have them in your library
if ("devtools" %in% rownames(installed.packages()) == 'FALSE') install.packages('devtools') 
library(devtools)
if ("segmented" %in% rownames(installed.packages()) == 'FALSE') install.packages('segmented') 
if ("plotrix" %in% rownames(installed.packages()) == 'FALSE') install.packages('plotrix') 
if ("gridExtra" %in% rownames(installed.packages()) == 'FALSE') install.packages('gridExtra') 
if ("LoLinR" %in% rownames(installed.packages()) == 'FALSE') install_github('colin-olito/LoLinR') 
if ("lubridate" %in% rownames(installed.packages()) == 'FALSE') install.packages('lubridate') 
if ("chron" %in% rownames(installed.packages()) == 'FALSE') install.packages('chron') 
if ("plyr" %in% rownames(installed.packages()) == 'FALSE') install.packages('plyr') 
if ("dplyr" %in% rownames(installed.packages()) == 'FALSE') install.packages('dplyr') 
if ("stringr" %in% rownames(installed.packages()) == 'FALSE') install.packages('stringr') 
if ("Rmisc" %in% rownames(installed.packages()) == 'FALSE') install.packages('Rmisc') 
if ("respR" %in% rownames(installed.packages()) == 'FALSE') install.packages('respR') 


#load packages
library("ggplot2")
library("segmented")
library("plotrix")
library("gridExtra")
library("LoLinR")
library("lubridate")
library("chron")
library('plyr')
library('dplyr')
library('stringr')
library('Rmisc')
library('respR')
library('tidyverse')

```

## Read in files  

Set the path of all respirometry files within the R project.   

```{r, warning=FALSE, message=FALSE}
path.p<-"data/temp_pi_curves/runs" #location of files
```

Bring in the file names.
```{r, warning=FALSE, message=FALSE}
# bring in the respiration file names
file.names<-basename(list.files(path = path.p, pattern = "csv$", recursive = TRUE)) 
```

Bring in the run metadata. 
```{r}
run_metadata<-read.csv("data/temp_pi_curves/Temp_PIcurves_SDR_Run_Info.csv")
```

```{r}
Sample.Info <- read_csv(file = "data/temp_pi_curves/Temp_PIcurves_SDR_Sample_Info.csv")%>%
  select(!Notes)%>%
  mutate(Date=as.character(Date))

# Load PI curve run metadata (i.e., light levels and interval times for each run)
Run.Info <- read_csv(file = "data/temp_pi_curves/Temp_PIcurves_SDR_Run_Info.csv")%>%
  mutate(Date=as.character(Date))%>%
  select(!Notes)

Light_Values <- unique(Run.Info$Light_Level)

# Join all coral and run metadata
metadata <- full_join(Sample.Info, Run.Info) 
```

## Extract oxygen rates from each light period 

Oxygen is in nmol/L in files. 

```{r}
# --- paths ---
input_dir  <- "data/temp_pi_curves/runs"
output_dir <- "output/temp_pi_curves/PhotosynthesisPlots"
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)

# --- files ---
files <- list.files(input_dir, pattern = "\\.csv$", full.names = TRUE)

# --- summary table ---
summary_df <- data.frame(
  Date = integer(),
  SDR = integer(),
  Run = integer(),
  Plate = character(), Well = character(),
  Light_Level = integer(), Light_Value = numeric(),
  IntervalStart = numeric(), IntervalStop = numeric(),
  Slope = numeric(), Intercept = numeric(),
  stringsAsFactors = FALSE
)

# --- helper: parse identifiers from filename ---
parse_ids <- function(f) {
  # Expect: 09_20230626_SDR641_Plate09_Run05_PR.csv
  re <- "^\\d{2}_(\\d{8})_SDR(\\d+)_Plate(\\d+)_Run(\\d+)_"
  m <- regexec(re, basename(f))
  g <- regmatches(basename(f), m)[[1]]
  if (length(g) < 5) stop("Filename doesn't match expected pattern: ", basename(f))
  list(
    Date       = as.integer(g[2]),
    SDR        = as.integer(g[3]),
    PlateNum   = as.integer(g[4]),
    Run        = as.integer(g[5]),
    PlateLabel = paste0("Plate", sprintf("%02d", as.integer(g[4])))
  )
}

#temporary problem solve plate 12 
#files<-list.files(input_dir, pattern = "\\Plate12_Run06_PR.csv$", full.names = TRUE)

# ---------- main loop ----------
for (file in files) {
  ids <- parse_ids(file)

  # match metadata rows for this file (now using Date + SDR + Plate + Run)
  meta_sub <- metadata %>%
    filter(Date == ids$Date,
           SDR  == ids$SDR,
           Plate == ids$PlateNum,
           Run  == ids$Run) %>%
    arrange(Light_Level, IntervalStart, IntervalStop) %>%
    distinct(Light_Level, Light_Value, IntervalStart, IntervalStop, .keep_all = TRUE)

  if (nrow(meta_sub) == 0) {
    message("No metadata match for file: ", basename(file))
    next
  }

  # read data
  data <- read_csv(file, skip = 12, show_col_types = FALSE)
  data$Time.Min <- seq.int(from = 0,
                           to   = ((nrow(data) * 0.25) - 0.25),
                           by   = 0.25)

  # subset wells
  data.sub <- data[, 3:26]

  # clean sensor error notifications and coerce to numeric
  data.sub[] <- lapply(data.sub, function(x) {
    x <- ifelse(grepl("[<>]", x), NA, x)
    suppressWarnings(as.numeric(x))
  })
  data.sub$Time.Min <- data$Time.Min

  # loop over each light interval in metadata
  for (i in seq_len(nrow(meta_sub))) {
    ll   <- meta_sub$Light_Level[i]
    lval <- meta_sub$Light_Value[i]
    t0   <- meta_sub$IntervalStart[i]
    t1   <- meta_sub$IntervalStop[i]

    # interval mask
    mask <- data.sub$Time.Min >= t0 & data.sub$Time.Min <= t1
    if (!any(mask)) next

    # per-well regression in this interval
    for (well_name in names(data.sub)[names(data.sub) != "Time.Min"]) {
      x <- data.sub$Time.Min[mask]
      y <- data.sub[[well_name]][mask]

      if (sum(!is.na(y)) < 5) next

      model <- try(
        rankLocReg(xall = x, yall = y, alpha = 0.4, method = "pc", verbose = FALSE),
        silent = TRUE
      )
      if (inherits(model, "try-error")) next
      if (is.null(model$allRegs) || length(model$allRegs$ciRange) == 0) next

      best_idx <- which.min(model$allRegs$ciRange)
      slope     <- model$allRegs$b1[best_idx]
      intercept <- model$allRegs$b0[best_idx]

      # make plot name unique across files and intervals
      plot_name <- paste0(
        ids$Date, "_SDR", ids$SDR, "_Run", sprintf("%02d", ids$Run), "_",
        ids$PlateLabel, "_", well_name,
        "_LL", ll, "_Start", t0, "_Stop", t1, "_regression_trunc.pdf"
      )

      pdf(file.path(output_dir, plot_name))
      plot(model)
      title(main = paste0(
        ids$Date, " SDR", ids$SDR, " Run", ids$Run, " ",
        ids$PlateLabel, " ", well_name,
        " | LL", ll, " (", lval, ") [", t0, "-", t1, " min]"
      ))
      dev.off()

      summary_df <- rbind(
        summary_df,
        data.frame(
          Date = ids$Date,
          SDR = ids$SDR,
          Run = ids$Run,
          Plate = ids$PlateLabel,
          Well = well_name,
          Light_Level = ll,
          Light_Value = lval,
          IntervalStart = t0,
          IntervalStop = t1,
          Slope = slope,
          Intercept = intercept,
          stringsAsFactors = FALSE
        )
      )
    }
  }
}

# Inspect / save summary
head(summary_df)

readr::write_csv(summary_df, file.path("output/temp_pi_curves/photosynthesis_slope_summary_by_light_level.csv"))
```

## Extract temperature information for each light period 

```{r}
# --- paths ---
input_dir  <- "data/temp_pi_curves/runs"
output_dir <- "output/temp_pi_curves/PhotosynthesisPlots"
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)

# --- files ---
files <- list.files(input_dir, pattern = "\\.csv$", full.names = TRUE)

# --- results table (plate-level only) ---
temp_summary_plate <- data.frame(
  Date = integer(),
  SDR = integer(),
  Run = integer(),
  Plate = character(),
  Light_Level = integer(), Light_Value = numeric(),
  IntervalStart = numeric(), IntervalStop = numeric(),
  Mean_T_internal_C = numeric(), N_points = integer(),
  stringsAsFactors = FALSE
)

# --- helper: parse identifiers from filename ---
parse_ids <- function(f) {
  # Expect: 09_20230626_SDR641_Plate09_Run05_PR.csv
  re <- "^\\d{2}_(\\d{8})_SDR(\\d+)_Plate(\\d+)_Run(\\d+)_"
  m <- regexec(re, basename(f))
  g <- regmatches(basename(f), m)[[1]]
  if (length(g) < 5) stop("Filename doesn't match expected pattern: ", basename(f))
  list(
    Date       = as.integer(g[2]),
    SDR        = as.integer(g[3]),
    PlateNum   = as.integer(g[4]),
    Run        = as.integer(g[5]),
    PlateLabel = paste0("Plate", sprintf("%02d", as.integer(g[4])))
  )
}

# ---------- main loop ----------
for (file in files) {
  ids <- parse_ids(file)

  # match metadata rows for this file (Date + SDR + Plate + Run)
  meta_sub <- metadata %>%
    filter(Date == ids$Date,
           SDR  == ids$SDR,
           Plate == ids$PlateNum,
           Run  == ids$Run) %>%
    arrange(Light_Level, IntervalStart, IntervalStop) %>%
    distinct(Light_Level, Light_Value, IntervalStart, IntervalStop, .keep_all = TRUE)

  if (nrow(meta_sub) == 0) {
    message("No metadata match for file: ", basename(file))
    next
  }

  # read full data
  data <- read_csv(file, skip = 12, show_col_types = FALSE)
  data$Time.Min <- seq.int(from = 0,
                           to   = ((nrow(data) * 0.25) - 0.25),
                           by   = 0.25)

  # temperature column (by name preferred; fallback to column 31)
  if ("T_internal [°C]" %in% names(data)) {
    tcol <- data[["T_internal [°C]"]]
  } else if (length(names(data)) >= 31) {
    tcol <- data[[31]]
    warning("Using column 31 as T_internal because 'T_internal [°C]' not found by name in: ",
            basename(file))
  } else {
    warning("No temperature column found in: ", basename(file))
    next
  }

  # loop over each light interval
  for (i in seq_len(nrow(meta_sub))) {
    ll   <- meta_sub$Light_Level[i]
    lval <- meta_sub$Light_Value[i]
    t0   <- meta_sub$IntervalStart[i]
    t1   <- meta_sub$IntervalStop[i]

    # time mask for this interval
    mask <- data$Time.Min >= t0 & data$Time.Min <= t1
    if (!any(mask)) next

    # compute mean temp (plate-level) in this interval
    mean_temp <- mean(tcol[mask], na.rm = TRUE)
    n_pts     <- sum(!is.na(tcol[mask]))

    # append one row per plate × interval
    temp_summary_plate <- rbind(
      temp_summary_plate,
      data.frame(
        Date = ids$Date,
        SDR = ids$SDR,
        Run = ids$Run,
        Plate = ids$PlateLabel,
        Light_Level = ll,
        Light_Value = lval,
        IntervalStart = t0,
        IntervalStop = t1,
        Mean_T_internal_C = mean_temp,
        N_points = n_pts,
        stringsAsFactors = FALSE
      )
    )
  }
}

# Inspect / save
head(temp_summary_plate)

readr::write_csv(temp_summary_plate, file.path("output/temp_pi_curves/mean_temperature_by_plate_and_light_interval.csv"))
```

## Prep oxygen data 

```{r}
head(summary_df)
head(metadata)

#merge in identifying information 
summary_df$Plate <- as.integer(sub("(?i)^plate", "", summary_df$Plate, perl = TRUE))  # removes leading "Plate"
summary_df$unique<-paste(summary_df$Date, summary_df$SDR, summary_df$Run, summary_df$Plate, summary_df$Well)
metadata$unique<-paste(metadata$Date, metadata$SDR, metadata$Run, metadata$Plate, metadata$Well)

summary_df$Type<-metadata$Type[match(summary_df$unique, metadata$unique)]
summary_df$Symbiont<-metadata$Symbiont[match(summary_df$unique, metadata$unique)]
summary_df$Temperature<-metadata$Temperature[match(summary_df$unique, metadata$unique)]
summary_df$Volume<-metadata$Volume[match(summary_df$unique, metadata$unique)]
summary_df$Org.Number<-metadata$Org.Number[match(summary_df$unique, metadata$unique)]

oxygen<-summary_df
```

## Standardize and normalize 

Remove samples that have inaccurate slope extraction for respiration rates (determined by PDF output files)  

```{r}
#Revisit this with PDFS 




```

Account for volume to obtain umol per minute.   

```{r, results=TRUE, warning=FALSE, message=FALSE}
#Account for chamber volume to convert from umol L-1 m-1 to umol m-1. This removes per Liter
oxygen$umol.min <- oxygen$Slope * oxygen$Volume #calculate

head(oxygen)

oxygen$code<-paste0(oxygen$Plate, "_", oxygen$Light_Level)
```

Subtract blank values. Average blank calculated for each light and run combination. Display mean blank value.
```{r}
blank_data <- subset(oxygen, Type == "Blank") #subset to blank data only

blank_data$code<-paste0(blank_data$Plate, "_", blank_data$Light_Level)

hist(blank_data$Slope)

plot(as.factor(blank_data$code), blank_data$umol.min, xlab="Plate", ylab="umol O2 min-1") #blanks 

#display mean blank values
mean(blank_data$umol.min, na.rm=TRUE) #mean P phase blanks

#remove outlier blank 
blank_data<-blank_data%>%
  filter(Slope>-2.5)%>%
  filter(Slope<1.2)

plot(as.factor(blank_data$code), blank_data$umol.min, xlab="Plate", ylab="umol O2 min-1") #blanks 

photo.blnk <- aggregate(umol.min ~ code, data=blank_data, mean) #calculate average blank during light for each run
colnames(photo.blnk)[colnames(photo.blnk) == 'umol.min'] <- 'Blank.umol.min' #rename to specify blank for R

oxygen <- full_join(oxygen, photo.blnk) #add R blanks to master
```

Subtract blank values to generate a "corrected" value for umol O2 min-1.  

```{r, warning=FALSE, message=FALSE}
oxygen$umol.min.corr<-oxygen$umol.min-oxygen$Blank.umol.min #subtract R blanks
```

```{r}
plot(oxygen$umol.min.corr)
```

Normalize to biologically relevant measure. Here, normalize to number of larvae. This can be substituted or changed for larval size/volume as well.  

```{r, warning=FALSE, message=FALSE}
oxygen.bio <- oxygen %>% filter(Type == "Sample") #isolate only biological samples and drop unused factor levels 
oxygen.bio <- droplevels(oxygen.bio) #drop unused factor levels

#respiration
oxygen.bio$umol.org.min <- oxygen.bio$umol.min.corr/oxygen.bio$Org.Number #calculate oxygen per organism 
oxygen.bio$nmol.org.min <- oxygen.bio$umol.org.min*1000 #calculate nanomoles 

```

Plot values.  
```{r}
plot(oxygen.bio$nmol.org.min)
```

Filter outliers. 
```{r}
oxygen.bio<-oxygen.bio%>%
  filter(nmol.org.min>-0.09)%>%
  filter(nmol.org.min<0.1)

plot(oxygen.bio$nmol.org.min)
```

Save as .csv file.  
```{r, warning=FALSE, message=FALSE}
write.csv(oxygen.bio, paste0("output/temp_pi_curves/temp_PIcurves_calculated_normalized_photo_rates.csv")) #save final file
```


